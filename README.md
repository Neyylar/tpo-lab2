# tpo-lab2

## Текст задания, систему функций.

Провести интеграционное тестирование программы, осуществляющей вычисление системы функций (в соответствии с вариантом).

### Вариант: 
100015

x <= 0 : csc(x)


![image](https://user-images.githubusercontent.com/61251909/191489311-97756425-9d25-4491-bd18-97377d19db3e.png)

x > 0 : (((((log_5(x) - log_2(x)) - log_10(x)) * (log_3(x) + log_2(x))) + log_3(x)) * ln(x))


![image](https://user-images.githubusercontent.com/61251909/191489181-cc5302a7-d01e-44ca-a98d-326a73c374d5.png)

Правила выполнения работы:

Все составляющие систему функции (как тригонометрические, так и логарифмические) должны быть выражены через базовые (тригонометрическая зависит от варианта; логарифмическая - натуральный логарифм).
Структура приложения, тестируемого в рамках лабораторной работы, должна выглядеть следующим образом (пример приведён для базовой тригонометрической функции sin(x)):

Обе "базовые" функции (в примере выше - sin(x) и ln(x)) должны быть реализованы при помощи разложения в ряд с задаваемой погрешностью. Использовать тригонометрические / логарифмические преобразования для упрощения функций ЗАПРЕЩЕНО.
Для КАЖДОГО модуля должны быть реализованы табличные заглушки. При этом, необходимо найти область допустимых значений функций, и, при необходимости, определить взаимозависимые точки в модулях.
Разработанное приложение должно позволять выводить значения, выдаваемое любым модулем системы, в сsv файл вида «X, Результаты модуля (X)», позволяющее произвольно менять шаг наращивания Х. Разделитель в файле csv можно использовать произвольный.
Порядок выполнения работы:

Разработать приложение, руководствуясь приведёнными выше правилами.
С помощью JUNIT4 разработать тестовое покрытие системы функций, проведя анализ эквивалентности и учитывая особенности системы функций. Для анализа особенностей системы функций и составляющих ее частей можно использовать сайт https://www.wolframalpha.com/.
Собрать приложение, состоящее из заглушек. Провести интеграцию приложения по 1 модулю, с обоснованием стратегии интеграции, проведением интеграционных тестов и контролем тестового покрытия системы функций.
Отчёт по работе должен содержать:




## UML-диаграмму классов разработанного приложения.

![image](https://user-images.githubusercontent.com/61251909/191494448-d1377bc6-0ab9-4f33-8e3d-54b7cd7b7fd6.png)

## Описание тестового покрытия с обоснованием его выбора.
Исходя из графиков граничные значения - 0 для обеих функций.

Для csc важно проверять значения, кратные PI, потому что в таком случае происходит деление на 0

Для функций логарифмов необходимо проверять значения 0 и менее нуля, потому то в таком случае функция не определена

Таким образом было выбрано тестовое покрытие от -PI до PI. Так же были проверены Infinity и неправильный ввод - NaN


## Графики, построенные csv-выгрузкам, полученным в процессе интеграции приложения.

![image](https://user-images.githubusercontent.com/61251909/191491542-e509df83-e0d8-4ab6-8f9c-0084fe0d44b1.png)

![image](https://user-images.githubusercontent.com/61251909/191492168-731e42f9-4950-48a1-849a-4c98cab62935.png)

![image](https://user-images.githubusercontent.com/61251909/191493750-aeb48c70-3dc4-46f3-aecd-473dd718cce5.png)


## Выводы по работе.

В ходе данной лабораторной работы я научилась использовать фреймворк Mockito, в частности mocks и spy для интеграционного тестирования. 

### Вопросы к защите лабораторной работы:

Цели и задачи интеграционного тестирования. Расположение фазы интеграционного тестирования в последовательности тестов; предшествующие и последующие виды тестирования ПО.
Алгоритм интеграционного тестирования.
Концепции и подходы, используемые при реализации интеграционного тестирования.
Программные продукты, используемые для реализации интеграционного тестирования. Использование JUnit для интеграционных тестов.
Автоматизация интеграционных тестов. ПО, используемое для автоматизации интеграционного тестирования.
